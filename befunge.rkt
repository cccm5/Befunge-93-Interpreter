(define (random-fcn)
  (let ((multiplier (expt 7 5))
        (modulus (- (expt 2 31) 1))
        (seed 19380110.0))
    (lambda ()
      (set! seed (modulo (* seed multiplier) modulus))
      (/ seed modulus))))
(define random-wrapper (random-fcn))
(define (random i)
  (inexact->exact (floor (* i (random-wrapper)))))

;generates a 2d grid based on vectors
(define (generate-grid width height)
  (define (helper index)
    (if (= index height)
        `()
        (cons (make-vector width #\ ) (helper (+ index 1)))))
  (list->vector (helper 0)))
;Display a 2d vector grid
(define (display-grid grid)
  (for-each (lambda (row) (begin (for-each (lambda (val) (write-char val))
                                           (vector->list row))
                                 (newline)))
            (vector->list grid)))
;Display a 2d vector grid with a highlighted index
(define (display-grid-pointer grid x y)
  (for-each (lambda (row j) (begin (for-each (lambda (val i) (if (and (= x i) (= y j)) (write-char #\â–ˆ) (display val)))
                                             (vector->list row)
                                             (list-from-to 0 (vector-length row)))
                                   (newline)))
            (vector->list grid)
            (list-from-to 0 (vector-length grid))))
;generates a list between two integers, [Start, end)
(define (list-from-to start end)
  (if (>= start end)
      `()
      (cons start (list-from-to (+ start 1) end))))
;null safe car
(define (peek stack)
  (if (null? stack)
      0
      (car stack)))
;null safe cdr
(define (pop stack)
  (if (null? stack)
      `()
      (cdr stack)))

(define (befunge . input-lines)
  (let* ((grid-height (length input-lines))
         (grid-width (apply max (map string-length  input-lines)))
         (grid (generate-grid grid-width grid-height))
         (pointer-x 0)
         (pointer-y 0)
         (x-velocity 1)
         (y-velocity 0)
         (string-mode? #f)
         (stack `()))
    ;returns the value at (x, y) in the grid
    (define (grid-ref x y)
      (if (or (< x 0) (>= x grid-width) (< y 0) (>= y grid-height))
          0
          (vector-ref  (vector-ref grid y) x)))
    ;destructivly sets the value at (x, y) in the grid to value
    (define (grid-set! x y value)
      (if (not (or (< x 0) (>= x grid-width) (< y 0) (>= y grid-height)))
          (vector-set! (vector-ref grid y) x value)))
    ;reads the input string list and inserts it into the grid
    (define (parse-input index)
      (if (not (= index grid-height))
          (begin (for-each (lambda (i x) (grid-set! x index i))
                           (string->list (list-ref input-lines index))
                           (list-from-to 0 (string-length (list-ref input-lines index))))
                 (parse-input (+ index 1)))))
    ;updates the pointer based on the x and y velocities
    (define (update-pointer)
      (begin (set! pointer-x (modulo (+ pointer-x x-velocity) grid-width))
             (set! pointer-y (modulo (+ pointer-y y-velocity) grid-height))))
    ;main execution loop
    (define (main-loop)
      (let ((instruction (grid-ref pointer-x pointer-y)))
        (cond (string-mode? (if (eq? instruction #\")
                                (set! string-mode? #f)
                                (set! stack (cons (char->integer instruction) stack))))
              ;right
              ((eq? instruction #\>) (begin (set! x-velocity 1)
                                            (set! y-velocity 0)))
              ;left
              ((eq? instruction #\<) (begin (set! x-velocity -1)
                                            (set! y-velocity 0)))
              ;up
              ((eq? instruction #\^) (begin (set! x-velocity 0)
                                            (set! y-velocity -1)))
              ;down
              ((eq? instruction #\v) (begin (set! x-velocity 0)
                                            (set! y-velocity 1)))
              ;random direction
              ((eq? instruction #\?) (let ((rand (random 4)))
                                       (set! x-velocity (* (quotient (- 3 rand) 2) (expt -1 rand)))
                                       (set! y-velocity (* (quotient  rand 2) (expt -1 rand)))))
              ;b+a (order: a b)
              ((eq? instruction #\+) (let ((a (peek stack))
                                           (b (peek (pop stack))))
                                       (set! stack (cons (+ a b) (pop (pop stack))))))
              ;b-a (order: a b)
              ((eq? instruction #\-) (let ((a (peek stack))
                                           (b (cadr stack)))
                                       (set! stack (cons (- b a) (pop (pop stack))))))
              ;a*b (order: a b)
              ((eq? instruction #\*) (let ((a (peek stack))
                                           (b (peek (pop stack))))
                                       (set! stack (cons (* a b) (pop (pop stack))))))
              ;floor b/a (order: a b)
              ((eq? instruction #\/) (let ((a (peek stack))
                                           (b (cadr stack)))
                                       (set! stack (cons (quotient  b a) (pop (pop stack))))))
              ;modulo b a (order: a b)
              ((eq? instruction #\%) (let ((a (peek stack))
                                           (b (peek (pop stack))))
                                       (set! stack (cons (modulo  b a) (pop (pop stack))))))
              ;logical not
              ((eq? instruction #\!) (if (not (= (peek stack) 0))
                                         (set-car! stack 0)
                                         (set-car! stack 1)))
              ;b > a (order: a b)
              ((eq? instruction #\`) (if (> (cadr stack) (peek stack))
                                         (set! stack (cons 1 (cddr stack)))
                                         (set! stack (cons 0 (cddr stack)))))
              ;vertical flow control
              ((eq? instruction #\_) (begin (set! y-velocity 0)
                                            (if (= (peek stack) 0)
                                                (set! x-velocity 1)
                                                (set! x-velocity -1))
                                            (set! stack (cdr stack))))
              ;horizantal flow control
              ((eq? instruction #\|) (begin (set! x-velocity 0)
                                            (if (= (peek stack) 0)
                                                (set! y-velocity 1)
                                                (set! y-velocity -1))
                                            (set! stack (cdr stack))))
              ;begin/end reading chars to the stack
              ((eq? instruction #\") (set! string-mode? #t))
              ;duplicate the top element of the stack
              ((eq? instruction #\:) (set! stack (cons (peek stack) stack)))
              ;discard the top element of the stack
              ((eq? instruction #\$) (set! stack (pop stack)))
              ;swap the top two elements of the stack
              ((eq? instruction #\\) (let ((a (peek stack))
                                           (b (peek (pop stack))))
                                       (set! stack (cons b (cons a (pop (pop stack)))))))
              ;display the top of the stack as an integer followed by a space
              ((eq? instruction #\.) (begin (display (peek stack))
                                            (write-char #\ )
                                            (set! stack (cdr stack))))
              ;display the top of the stack as a char
              ((eq? instruction #\,) (begin (write-char (integer->char (peek stack)))
                                            (set! stack (cdr stack))))
              ;skip the next instruction
              ((eq? instruction #\#) (update-pointer))
              ;set value v at x y (order: y x v)
              ((eq? instruction #\p) (let ((y (peek stack))
                                           (x (peek (pop stack)))
                                           (v (peek (pop (pop stack)))))
                                       (set! stack (pop (pop (pop stack))))
                                       (grid-set! x y (integer->char v))))
                                       ;(display-grid-pointer grid pointer-x pointer-y)))
              ;get value at x y (order: y x)
              ((eq? instruction #\g) (let ((y (peek stack))
                                           (x (peek (pop stack))))
                                       (if (or (< x 0) (>= x grid-width) (< y 0) (>= y grid-height))
                                           (set! stack (cons 0 (pop (pop stack))))
                                           (set! stack (cons (char->integer (grid-ref x y)) (pop (pop stack)))))))
              ;ask user for number
              ((eq? instruction #\&) (set! stack (cons (read) stack)))
              ;ask user for char
              ((eq? instruction #\~) (set! stack (cons (char->integer (read-char)) stack)))
              ((char-numeric? instruction) (set! stack (cons (- (char->integer instruction) 48) stack)))))
      (update-pointer)
      ;(newline)
      ;(display-grid-pointer grid pointer-x pointer-y)
      ;(newline)
      ;(display stack)
      (if (or string-mode? (not (eq? (grid-ref pointer-x pointer-y) #\@)))
          (main-loop)))
    (begin (parse-input 0)
           (display-grid grid)
           (main-loop))))